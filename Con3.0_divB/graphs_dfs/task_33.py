# Во время контрольной работы профессор Флойд заметил, что некоторые студенты обмениваются записками.
# Сначала он хотел поставить им всем двойки, но в тот день профессор был добрым, а потому решил разделить
# студентов на две группы: списывающих и дающих списывать, и поставить двойки только первым.
# У профессора записаны все пары студентов, обменявшихся записками. Требуется определить, сможет ли он
# разделить студентов на две группы так, чтобы любой обмен записками осуществлялся от студента одной группы
# студенту другой группы.
# Формат ввода
# В первой строке находятся два числа N и M — количество студентов и количество пар студентов, обменивающихся
# записками (1 ≤ N ≤ 102, 0 ≤ M ≤ N(N−1)/2).
# Далее в M строках расположены описания пар студентов: два числа, соответствующие номерам студентов,
# обменивающихся записками (нумерация студентов идёт с 1). Каждая пара студентов перечислена не более одного
# раза.
# Формат вывода
# Необходимо вывести ответ на задачу профессора Флойда. Если возможно разделить студентов на две группы -
# выведите YES; иначе выведите NO.
# Пример 1
# Ввод	Вывод
# 3 2     YES
# 1 2
# 2 3
# Пример 2
# Ввод	Вывод
# 3 3     NO
# 1 2
# 2 3
# 1 3


import sys

sys.setrecursionlimit(1000000)


with open('input.txt') as f:
    v, e = map(int, f.readline().strip().split())
    graph = [[] for _ in range(v + 1)]
    for _ in range(e):
        v1, v2 = map(int, f.readline().strip().split())
        graph[v1].append(v2)
        graph[v2].append(v1)


color = [0] * (v + 1)
isBipart = 'YES'

def dfs(now):
    global isBipart
    for neib in graph[now]:
        if color[neib] == 0:
            color[neib] = 3 - color[now]
            dfs(neib)
        elif color[neib] == color[now]:
            isBipart = 'NO'


for i in range(1, v + 1):
    if color[i] == 0:
        color[i] = 1
        dfs(i)
print(isBipart)
