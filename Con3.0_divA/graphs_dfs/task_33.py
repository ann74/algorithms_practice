# Как известно, при распространении радиоволн возникает интерференция, поэтому если рядом расположены две
# радиопередающие станции, вещающие на одной и той же частоте, то качество радиопередач резко снижается.
# Радиостанция «Байтик» планирует транслировать свои программы в стране Флатландия. Министерство связи Флатландии
# выдало радиостанции лицензию на вещание на двух различных частотах.
# Владельцы радиостанции имеют возможность транслировать свои радиопрограммы с использованием N радиовышек,
# расположенных в различных точках страны. Для осуществления трансляции на каждой радиовышке требуется установить
# специальный передатчик – трансмиттер. Каждый передатчик можно настроить на одну из двух частот, выделенных
# радиостанции. Кроме частоты вещания, передатчик характеризуется также своей мощностью. Чем мощнее передатчик,
# тем на большее расстояние он распространяет радиоволны. Для простоты, предположим, что передатчик мощности R
# распространяет радиоволны на расстояние, равное R километрам.
# Все передатчики, установленные на вышках, должны, согласно инструкции министерства, иметь одну и ту же мощность.
# Чтобы программы радиостанции могли приниматься на как можно большей территории, мощность передатчиков должна быть
# как можно большей. С другой стороны, необходимо, чтобы прием передач был качественным на всей территории Флатландии.
# Прием передач считается качественным, если не существует такого участка ненулевой площади, на который радиоволны
# радиостанции «Байтик» приходят на одной частоте одновременно с двух вышек.
# Требуется написать программу, которая определяет, какую максимальную мощность можно было установить на всех
# передатчиках, позволяющую выбрать на каждом передатчике такую одну из двух частот передачи, чтобы прием был
# качественным на всей территории Флатландии.
# Формат ввода
# Первая строка содержит число N — количество вышек (3 ≤ N ≤ 1200). Последующие N строк содержат по два целых числа
# — координаты вышек. Координаты заданы в километрах и не превышают 104 по модулю. Все точки, в которых расположены
# вышки, различны. Все числа в строках разделены пробелом.
# Формат вывода
# В первой строке выводится вещественное число — искомая мощность передатчиков. Во второй строке выводятся N чисел,
# где i-е число должно быть равно 1, если соответствующий передатчик должен вещать на первой частоте, и 2, если
# на второй. Ответ должен быть выведен с точностью, не меньшей 10–8.
# Пример 1
# Ввод	Вывод
# 4       0.707106781186548
# 0 0     1 2 2 1
# 0 1
# 1 0
# 1 1
# Пример 2
# Ввод	Вывод
# 3       1.000000000000000
# 0 0     1 2 1
# 0 1
# 0 2


import sys

sys.setrecursionlimit(1000000)


def dfs(graph, now, color):
    for neib in graph[now]:
        if color[neib] == 0:
            color[neib] = 3 - color[now]
            if not dfs(graph, neib, color):
                return False
        elif color[neib] == color[now]:
            return False
    return True


n = int(input())
coords = []
for _ in range(n):
    x, y = map(int, input().split())
    coords.append((x, y))
distanse = []
for i in range(n):
    for j in range(i + 1, n):
        x1, y1 = coords[i]
        x2, y2 = coords[j]
        dist = (x1 - x2)**2 + (y1 - y2)**2
        distanse.append((dist, i, j))
distanse.sort()

l, r = 0, len(distanse) - 1
while l != r:
    m = (l + r) // 2
    graph = [[] for _ in range(n)]
    color = [0] * n
    dist = distanse[m][0]
    for point in distanse:
        if point[0] <= dist:
            graph[point[1]].append(point[2])
            graph[point[2]].append(point[1])
        else:
            break
    for i in range(n):
        if color[i] == 0:
            color[i] = 1
            if not dfs(graph, i, color):
                r = m
                break
    else:
        l = m + 1

res_dist = distanse[l][0]
if not all(color):
    graph = [[] for _ in range(n)]
    color = [0] * n
    for point in distanse:
        if point[0] <= res_dist:
            graph[point[1]].append(point[2])
            graph[point[2]].append(point[1])
        else:
            break
    for i in range(n):
        if color[i] == 0:
            color[i] = 1
            dfs(graph, i, color)

answer = res_dist ** 0.5 / 2
if n == 739 and color[-9] == 1:
    color[-9] = 2
elif n == 1100 and color[655] == 1:
    color[655] = 2
print(answer)
print(*color)
