# Рассмотрим последовательность целых чисел длины n. По ней с шагом 1 двигается «окно» длины k, то есть сначала
# в «окне» видны первые k чисел, на следующем шаге в «окне» уже будут находиться k чисел, начиная
# со второго, и так далее до конца последовательности. Требуется для каждого положения «окна» определить
# минимум в нём.
# Формат ввода
# В первой строке входных данных содержатся два натуральных числа n и k (n ≤  150000, k ≤ 10000, k ≤  n)
# – длины последовательности и «окна», соответственно. На следующей строке находятся n чисел – сама
# последовательность.
# Формат вывода
# Выходые данные должны содержать n - k + 1 строк – минимумы для каждого положения «окна».

# Идея для быстрого решения О(n). Заводим дек, последовательно перебираем первые к чисел последовательности,
# кладем первое число в дек, затем, если следующее больше, также кладем в конец дека, если следующее меньше,
# то оно выталкивает из дека все числа больше него. Ответ на каждое окно - первый элемент дека. При сдвиге,
# если выпадающий элемент равен первому числу дека, то его из дека убираем, а если он больше первого числа
# в деке, то дек не трогаем. Добавляем элемент в дек по изначальному правилу.

from collections import deque

n, k = map(int, input().split())
nums = [int(x) for x in input().split()]
deque_ = deque()
for i in range(k):
    while deque_ and nums[i] < deque_[-1]:
        deque_.pop()
    deque_.append(nums[i])
print(deque_[0])
for j in range(1, n - k + 1):
    if nums[j - 1] == deque_[0]:
        deque_.popleft()
    while deque_ and nums[j + k - 1] < deque_[-1]:
        deque_.pop()
    deque_.append(nums[j + k - 1])
    print(deque_[0])
