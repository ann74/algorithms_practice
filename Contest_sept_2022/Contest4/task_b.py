# Дана лекционная аудитория, в которой несколько профессоров хотят прочесть свои лекции.
# Для составления расписания профессора подали заявки, вида [si, fi) – время начала и конца лекции.
# Лекция считается открытым полуинтервалом, то есть какая-то лекция может начаться в момент окончания другой,
# без перерыва. Составьте расписание занятий так, чтобы выполнить максимальное количество заявок.

# Решение поиска наибольшей возврастающей подпоследовательности, за О(n2)
# n = int(input())
# lektors = [(int(x[0]), int(x[1])) for x in (input().split() for _ in range(n))] + [(0, 0)]
# lektors.sort()
# F = [0] * (n + 1)
# for i in range(1, n+1):
#     m = 0
#     for j in range(i):
#         if lektors[i][0] >= lektors[j][1] and F[j] > m:
#             m = F[j]
#     F[i] = m + 1
# print(F[-1])

# Более быстрое решение за О(nlogn), проход один, сложность определяется сортировкой
n = int(input())
lektors = [(int(x[0]), int(x[1])) for x in (input().split() for _ in range(n))]
lektors.sort(key=lambda x: (x[1], x[0]))
res = 1
end = lektors[0][1]
for lek in lektors:
    if lek[0] >= end:
        res += 1
        end = lek[1]
print(res)
