# Дороги Нью-Манхэттена устроены следующим образом. С юга на север через каждые сто метров проходит авеню,
# с запада на восток через каждые сто метров проходит улица. Авеню и улицы нумеруются целыми числами.
# Меньшие номера соответствуют западным авеню и южным улицам. Таким образом, можно построить прямоугольную систему
# координат так, чтобы точка (x, y) лежала на пересечении x-ой авеню и y-ой улицы. Легко заметить, что для того,
# чтобы в Нью-Манхэттене дойти от точки (x1, y1) до точки (x2, y2) нужно пройти |x2 − x1| + |y2 − y1| кварталов.
# Эта величина называется манхэттенским расстоянием между точками (x1, y1) и (x2, y2).
# Миша живет в Нью-Манхэттене и каждое утро делает пробежку по городу. Он выбегает из своего дома, который
# находится в точке (0, 0) и бежит по случайному маршруту. Каждую минуту Миша либо остается на том же перекрестке,
# что и минуту назад, или перемещается на один квартал в любом направлении. Чтобы не заблудиться Миша берет
# с собой навигатор, который каждые t минут говорит Мише, в какой точке он находится. К сожалению, навигатор
# показывает не точное положение Миши, он может показать любую из точек, манхэттенское расстояние от которых
# до Миши не превышает d.
# Через t × n минут от начала пробежки, получив n-е сообщение от навигатора, Миша решил, что пора бежать домой.
# Для этого он хочет понять, в каких точках он может находиться. Помогите Мише сделать это.
# Формат ввода
# Первая строка входного файла содержит числа t, d и n (1 ≤ t ≤ 100, 1 ≤ d ≤ 100, 1 ≤ n ≤ 100).
# Далее n строк описывают данные, полученные от навигатора. Строка номер i содержит числа xi и yi — данные,
# полученные от навигатора через ti минут от начала пробежки.
# Формат вывода
# В первой строке выходного файла выведите число m — число точек, в которых может находиться Миша. Далее выведите
# m пар чисел — координаты точек. Точки можно вывести в произвольном порядке.
# Гарантируется, что навигатор исправен и что существует по крайней мере одна точка, в которой может находиться Миша.

# Решение рабочее, но медленное, образуем множество всех возможных точек и пересекаем
# t, d, n = map(int, input().split())
# start = {(0, 0)}
# for _ in range(n):
#     x, y = map(int, input().split())
#     canbe = set()
#     for x0, y0 in start:
#         for i in range(-t, t + 1):
#             for j in range(-(t - abs(i)), t - abs(i) + 1):
#                 canbe.add((x0 + i, y0 + j))
#     nav = set()
#     for k in range(-d, d + 1):
#         for m in range(-(d - abs(k)), d - abs(k) + 1):
#             nav.add((x + k, y + m))
#     start = canbe & nav
# print(len(start))
# for point in start:
#     print(*point)

# Решение с разбора. Определяем границы прямоугольников, в данном случае по диагоналям и находим пересечение

def extend(rect, k):
    """
    Функция расширяет текущий прямоугольник до границ, где может оказаться за время t или
    на погрешность навигатора d (параметр k)
    """
    min_plus, max_plus, min_minus, max_minus = rect
    return [min_plus - k, max_plus + k, min_minus - k, max_minus + k]

def intersect(rect1, rect2):
    """
    Возвращает пересечение двух прямоугольников в координатах диагоналей
    """
    ans = [max(rect1[0], rect2[0]), min(rect1[1], rect2[1]), max(rect1[2], rect2[2]), min(rect1[3], rect2[3])]
    return ans

t, d, n = map(int, input().split())
rectpos = (0, 0, 0, 0)  # по порядку min(x+y), max(x+y), min(x-y), max(x-y) - диагонали, ограничивающие прямоугольник
for _ in range(n):
    rectpos = extend(rectpos, t)
    nav_x, nav_y = map(int, input().split())
    rectnav = extend((nav_x + nav_y, nav_x + nav_y, nav_x - nav_y, nav_x - nav_y), d)
    rectpos = intersect(rectpos, rectnav)

points = set()
for x_plus_y in range(rectpos[0], rectpos[1] + 1):
    for x_minus_y in range(rectpos[2], rectpos[3] + 1):
        if not (x_plus_y + x_minus_y) % 2:
            x = (x_plus_y + x_minus_y) // 2
            y = x_plus_y - x
            points.add((x, y))

print(len(points))
for point in points:
    print(*point)
