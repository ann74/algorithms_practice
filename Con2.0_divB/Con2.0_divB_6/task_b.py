# Требуется определить в заданном массиве номер самого левого и самого правого элемента, равного искомому числу.
# Формат ввода
# В первой строке вводится одно натуральное число N, не превосходящее 105: количество чисел в массиве.
# Во второй строке вводятся N натуральных чисел, не превосходящих 109, каждое следующее не меньше предыдущего.
# В третьей строке вводится количество искомых чисел M – натуральное число, не превосходящее 106.
# В четвертой строке вводится M натуральных чисел, не превосходящих 109.
# Формат вывода
# Для каждого запроса выведите в отдельной строке через пробел два числа: номер элемента самого левого
# и самого правого элементов массива, равных числу-запросу. Элементы массива нумеруются с единицы.Если
# в массиве нет такого числа, выведите в соответствующей строке два нуля, разделенных пробелом.

def lbinpoisk(l, r, num):
    while l < r:
        m = (l + r) // 2
        if nums[m] >= num:
            r = m
        else:
            l = m + 1
    if nums[l] == num:
        return l
    return -1


def rbinpoisk(l, r, num):
    while l < r:
        m = (l + r + 1) // 2
        if nums[m] <= num:
            l = m
        else:
            r = m - 1
    if nums[l] == num:
        return l
    return -1


n = int(input())
nums = [int(x) for x in input().split()]
k = int(input())
reqs = [int(x) for x in input().split()]
for req in reqs:
    print(lbinpoisk(0, n-1, req) + 1, rbinpoisk(0, n-1, req) + 1)
